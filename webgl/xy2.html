<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGL坐标轴实现 | Blender风格</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      body {
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        color: #ecf0f1;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      .header {
        text-align: center;
        padding: 30px 0;
        margin-bottom: 20px;
        z-index: 10;
      }

      h1 {
        font-size: 2.8rem;
        margin-bottom: 15px;
        text-shadow: 0 0 15px rgba(46, 204, 113, 0.7);
        background: linear-gradient(to right, #3498db, #2ecc71);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: 1px;
      }

      .subtitle {
        font-size: 1.2rem;
        max-width: 600px;
        margin: 0 auto;
        line-height: 1.6;
        color: #a0c4e4;
      }

      .container {
        position: relative;
        width: 90vmin;
        height: 70vmin;
        max-width: 800px;
        max-height: 600px;
        margin: 0 auto;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid rgba(52, 152, 219, 0.4);
        background: #0a0e17;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      .info {
        max-width: 800px;
        margin: 30px auto;
        padding: 25px;
        background: rgba(20, 25, 40, 0.7);
        border-radius: 15px;
        text-align: center;
        border: 1px solid rgba(52, 152, 219, 0.3);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        z-index: 10;
      }

      .info p {
        margin: 15px 0;
        line-height: 1.7;
        color: #b4d2f0;
      }

      .axis-info {
        display: flex;
        justify-content: center;
        gap: 25px;
        margin-top: 20px;
        flex-wrap: wrap;
      }

      .axis-card {
        min-width: 120px;
        background: rgba(30, 40, 60, 0.8);
        padding: 15px;
        border-radius: 10px;
        text-align: center;
        border-top: 4px solid;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }

      .axis-card.x-axis {
        border-top-color: #e74c3c;
      }

      .axis-card.y-axis {
        border-top-color: #2ecc71;
      }

      .axis-card.z-axis {
        border-top-color: #3498db;
      }

      .axis-card h3 {
        margin-bottom: 10px;
        font-size: 1.1rem;
      }

      .axis-card .axis-color {
        width: 25px;
        height: 25px;
        border-radius: 50%;
        margin: 0 auto 10px;
      }

      .x-axis .axis-color {
        background: #e74c3c;
        box-shadow: 0 0 10px #e74c3c;
      }

      .y-axis .axis-color {
        background: #2ecc71;
        box-shadow: 0 0 10px #2ecc71;
      }

      .z-axis .axis-color {
        background: #3498db;
        box-shadow: 0 0 10px #3498db;
      }

      .background-elements {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
      }

      .bg-circle {
        position: absolute;
        border-radius: 50%;
        opacity: 0.05;
        filter: blur(60px);
      }

      .bg-circle:nth-child(1) {
        width: 300px;
        height: 300px;
        background: #3498db;
        top: 10%;
        left: 10%;
      }

      .bg-circle:nth-child(2) {
        width: 400px;
        height: 400px;
        background: #e74c3c;
        bottom: 10%;
        right: 15%;
      }

      .bg-circle:nth-child(3) {
        width: 250px;
        height: 250px;
        background: #2ecc71;
        top: 50%;
        left: 40%;
      }

      footer {
        text-align: center;
        margin-top: 40px;
        padding: 20px;
        color: #7f8c8d;
        font-size: 0.9rem;
        z-index: 10;
      }

      @media (max-width: 768px) {
        h1 {
          font-size: 2.2rem;
        }

        .container {
          width: 95vmin;
          height: 75vmin;
        }

        .axis-info {
          gap: 15px;
        }

        .axis-card {
          min-width: 100px;
        }
      }
    </style>
  </head>
  <body>
    <div class="background-elements">
      <div class="bg-circle"></div>
      <div class="bg-circle"></div>
      <div class="bg-circle"></div>
    </div>

    <div class="container">
      <canvas id="webgl-canvas"></canvas>
    </div>

    <script>
      // 初始化WebGL
      function initWebGL() {
        const canvas = document.getElementById("webgl-canvas");
        const gl =
          canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

        if (!gl) {
          alert("您的浏览器不支持WebGL");
          return;
        }

        // 设置画布尺寸
        canvas.width = canvas.clientWidth * devicePixelRatio;
        canvas.height = canvas.clientHeight * devicePixelRatio;
        gl.viewport(0, 0, canvas.width, canvas.height);

        // 创建着色器程序
        const shaderProgram = initShaderProgram(gl);

        // 创建坐标轴数据
        const { vertices, colors } = createAxisData();

        // 创建缓冲区
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(vertices),
          gl.STATIC_DRAW
        );

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(colors),
          gl.STATIC_DRAW
        );

        // 设置透视矩阵
        const aspect = canvas.width / canvas.height;
        const projectionMatrix = mat4.create();
        mat4.perspective(projectionMatrix, Math.PI / 3, aspect, 0.1, 100.0);

        // 设置视图矩阵 (从(3,3,3)看向原点)
        const viewMatrix = mat4.create();
        mat4.lookAt(viewMatrix, [3, 3, 3], [0, 0, 0], [0, 1, 0]);

        // 合并视图投影矩阵
        const viewProjectionMatrix = mat4.create();
        mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);

        // 设置统一变量
        const matrixLocation = gl.getUniformLocation(shaderProgram, "u_matrix");
        gl.uniformMatrix4fv(matrixLocation, false, viewProjectionMatrix);

        // 设置顶点属性
        const positionAttributeLocation = gl.getAttribLocation(
          shaderProgram,
          "a_position"
        );
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(
          positionAttributeLocation,
          3,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(positionAttributeLocation);

        const colorAttributeLocation = gl.getAttribLocation(
          shaderProgram,
          "a_color"
        );
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.vertexAttribPointer(
          colorAttributeLocation,
          3,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(colorAttributeLocation);

        // 启用深度测试
        gl.enable(gl.DEPTH_TEST);

        // 渲染循环
        function render() {
          // 清除画布
          gl.clearColor(0.05, 0.05, 0.1, 1.0);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

          // 绘制坐标轴
          gl.useProgram(shaderProgram);
          gl.drawArrays(gl.LINES, 0, vertices.length / 3);

          requestAnimationFrame(render);
        }

        render();
      }

      // 创建坐标轴数据
      function createAxisData() {
        const vertices = [];
        const colors = [];

        // 添加坐标轴 (X: 红色, Y: 绿色, Z: 蓝色)
        addAxis(vertices, colors, [1, 0, 0], [1, 0, 0]); // X轴
        addAxis(vertices, colors, [0, 1, 0], [0, 1, 0]); // Y轴
        addAxis(vertices, colors, [0, 0, 1], [0, 0, 1]); // Z轴

        return { vertices, colors };
      }

      // 添加单个坐标轴
      function addAxis(vertices, colors, direction, color) {
        const axisLength = 1.5;
        const arrowSize = 0.2;

        // 主轴 (从原点到方向)
        // 起点 (0,0,0)
        vertices.push(0, 0, 0);
        colors.push(...color);

        // 终点
        vertices.push(
          direction[0] * axisLength,
          direction[1] * axisLength,
          direction[2] * axisLength
        );
        colors.push(...color);

        // 箭头部分 (两个斜线)
        const end = [
          direction[0] * axisLength,
          direction[1] * axisLength,
          direction[2] * axisLength,
        ];

        // 计算垂直向量
        let perp;
        if (direction[0] !== 0) {
          perp = [0, 1, 0]; // 如果方向不是垂直的，使用Y轴作为垂直向量
        } else {
          perp = [1, 0, 0]; // 否则使用X轴
        }

        // 箭头点1
        vertices.push(...end);
        colors.push(...color);

        vertices.push(
          end[0] - direction[0] * arrowSize + perp[0] * arrowSize * 0.5,
          end[1] - direction[1] * arrowSize + perp[1] * arrowSize * 0.5,
          end[2] - direction[2] * arrowSize + perp[2] * arrowSize * 0.5
        );
        colors.push(...color);

        // 箭头点2
        vertices.push(...end);
        colors.push(...color);

        vertices.push(
          end[0] - direction[0] * arrowSize - perp[0] * arrowSize * 0.5,
          end[1] - direction[1] * arrowSize - perp[1] * arrowSize * 0.5,
          end[2] - direction[2] * arrowSize - perp[2] * arrowSize * 0.5
        );
        colors.push(...color);
      }

      // 初始化着色器程序
      function initShaderProgram(gl) {
        // 顶点着色器
        const vsSource = `
                attribute vec3 a_position;
                attribute vec3 a_color;
                
                uniform mat4 u_matrix;
                
                varying vec3 v_color;
                
                void main() {
                    gl_Position = u_matrix * vec4(a_position, 1.0);
                    v_color = a_color;
                }
            `;

        // 片段着色器
        const fsSource = `
                precision mediump float;
                
                varying vec3 v_color;
                
                void main() {
                    gl_FragColor = vec4(v_color, 1.0);
                }
            `;

        // 创建着色器
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

        // 创建着色器程序
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert("无法初始化着色器程序: " + gl.getProgramInfoLog(shaderProgram));
          return null;
        }

        return shaderProgram;
      }

      // 加载着色器
      function loadShader(gl, type, source) {
        const shader = gl.createShader(type);

        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert("编译着色器时出错: " + gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      // 使用glMatrix库进行矩阵操作
      const mat4 = {
        create: function () {
          return new Float32Array(16);
        },
        perspective: function (out, fovy, aspect, near, far) {
          const f = 1.0 / Math.tan(fovy / 2);
          out[0] = f / aspect;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = f;
          out[6] = 0;
          out[7] = 0;
          out[8] = 0;
          out[9] = 0;
          out[10] = (far + near) / (near - far);
          out[11] = -1;
          out[12] = 0;
          out[13] = 0;
          out[14] = (2 * far * near) / (near - far);
          out[15] = 0;
          return out;
        },
        lookAt: function (out, eye, center, up) {
          let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;

          // 计算方向向量
          z0 = eye[0] - center[0];
          z1 = eye[1] - center[1];
          z2 = eye[2] - center[2];

          // 归一化
          len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
          z0 *= len;
          z1 *= len;
          z2 *= len;

          // 计算右向量
          x0 = up[1] * z2 - up[2] * z1;
          x1 = up[2] * z0 - up[0] * z2;
          x2 = up[0] * z1 - up[1] * z0;

          // 归一化
          len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
          if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
          } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
          }

          // 计算上向量
          y0 = z1 * x2 - z2 * x1;
          y1 = z2 * x0 - z0 * x2;
          y2 = z0 * x1 - z1 * x0;

          // 归一化
          len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
          if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
          } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
          }

          out[0] = x0;
          out[1] = y0;
          out[2] = z0;
          out[3] = 0;
          out[4] = x1;
          out[5] = y1;
          out[6] = z1;
          out[7] = 0;
          out[8] = x2;
          out[9] = y2;
          out[10] = z2;
          out[11] = 0;
          out[12] = -(x0 * eye[0] + x1 * eye[1] + x2 * eye[2]);
          out[13] = -(y0 * eye[0] + y1 * eye[1] + y2 * eye[2]);
          out[14] = -(z0 * eye[0] + z1 * eye[1] + z2 * eye[2]);
          out[15] = 1;

          return out;
        },
        multiply: function (out, a, b) {
          const a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a03 = a[3];
          const a10 = a[4],
            a11 = a[5],
            a12 = a[6],
            a13 = a[7];
          const a20 = a[8],
            a21 = a[9],
            a22 = a[10],
            a23 = a[11];
          const a30 = a[12],
            a31 = a[13],
            a32 = a[14],
            a33 = a[15];

          let b0 = b[0],
            b1 = b[1],
            b2 = b[2],
            b3 = b[3];
          out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

          b0 = b[4];
          b1 = b[5];
          b2 = b[6];
          b3 = b[7];
          out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

          b0 = b[8];
          b1 = b[9];
          b2 = b[10];
          b3 = b[11];
          out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

          b0 = b[12];
          b1 = b[13];
          b2 = b[14];
          b3 = b[15];
          out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return out;
        },
      };

      // 启动WebGL
      window.onload = initWebGL;
    </script>
  </body>
</html>
